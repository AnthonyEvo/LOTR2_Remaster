	--- Заметки по OkTree Data Base ---
	
		1. Алгоритм создания базы это заполнение прямоугольной декартовой сетки максимально 
		большими ячейками в пределах начального размера игрового (визуального) объема. Возможно максимальный 
		размер будет всего одна ячейка если	она достаточно большая для заполнения ее внутриигровыми объектами. 
		Важно предусмотреть ограничения и исключения при рисовании объектов разного размера в пределах 
		минимальной ячейки, осбенно важен объем их детализации.	
		
		2. Отслеживание объектов для отрисовки должно идти каскадом от самой большой ящейки до самой малой.
		Алгоритм следующий - камера запрашивает большие ячейки у БД, получает ячейки с которыми пересекается
		ее область обзора.
		Для реализации этого понадбится "Bound box" причем несколько его видов. Потом у ячеек
		камера запрашивает подъячейки, это повторяется до самого малого их размера. 
		После камера получает список объектов из ячеек которые были отфильтрованы из базы. 
		После идет фильтрация тех объектов которые попали в поле зрения камеры, 
		остальные кэшируются для дальнейшего использованя в случае разворота камеры.
		
		3. База объектов для игры должна быть универсальной при использовании ее как для логики игры, так и для
		других целей. Это означает что сохранение игровых сессий не должно быть тем же процессом, что и сохранение 
		объектов графики, композиций объектов и других результатов работы графического движка.
		
		4. Нужна будет база объектов для тестирования работы движка.
		
	--- Общие заметки (или заметки которые еще не специализированны) ---
	
		1. Последовательность работы при обработке графики:
		
			1.1 Добавление данных в базу отрисовки;
				- нужен алгоритм добавления объектов в базу, пока речь только об OkTree
				Объект нужно маркировать на каждой ступени базы, а также он должен менять свою маркировку при
				пересечении границ ячеек базы, это вызовет дополнительные расходы производительности.
				
			1.2 Добавление в базу активных маркеров отрисовки (т.е. камер) также камеры нужно 
			добавить в отдельный список для ускорения доступа;
				- Список должен быть привязан к среде одного воплощения\источника (Instance), возможно
				это таже база данных просто с отдельным списком для спецобъектов
				
			1.3 Прохождение алгоритма фильтрации объектов;
				- алгоритмы фильтрации объектов для разных баз будут свои и описаны в заметках про базы данных
				
			1.4 Рисование объекта в привязанном интерфейсе.
				- потребуется преработка системы отображения и сборка сетевого клинта, который сможет отправлять
				информацию на другой ПК.
				- нужно продумать способ обновления собранного проекта до актуальной версии, 
				чтобы система могла обновить себя сама имея определенным образом маркированный пакет с новыми
				исполняемыми файлами. 
		
		2. Правильный подход к внутриигровым расчетам
		
			2.1 Нужно построить систему таким образом, что бы задачи объектов по расчету их взаимодействий
			и внутренних операций масштабировались на количество исполнителей и не зависели друг от друга.
			По сути построить это взаимодействие таким образом: 
			конетйнер с задачей -> расчет -> возврат контейнера с результатом.
			
			2.2 В такой системе нужно иметь какие-то стандартные контейнеры для расчетов и достаточно простой
			алгоритм расчета для каждого контейнера. Под простотой тут подразумевается что инструмент для 
			их обработки должен быть универсальными. Получается что в рамках одного клиентского приложения 
			есть три отдельных типа объекта, первый тип объектов сосредоточен на вмещении в себе объектов и обмене 
			информацией второй на обработке состояний и поведения объектов в соответствии с правилами, третий на
			передаче команд влияющих на поведение обектов и на их отображении для пользователя. Третий тип все же 
			не полноценный из-за того, что его наличие не обязательно для продолжения работы.
			
			2.3 Просматривается следующая система:
			- условно первый тип это базы данных и инструменты анализа их содержимого, а также системы связи с ними;
			- второй тип это обработчики событий и инструменты контроля выполняющие задачи по испольнению правил
			поведения объектов, обработке их внутренних расчетов
			- третий тип чем-то похож на второй тип, он также как и второй запрашивает определенные объекты у базы
			данных, и выполняет определенную обработку этих объектов устанавливая им маркеры управления для 
			обработчиков событий.
			
			2.4 Если продолжать логику то условно три типа объетов позволяют построить своего рода треугольник
			в котором основным элементом для взаимодействия выступает база данных. Но если пытаться расширить 
			систему то трех элементов становится мало. В случае если в такой системе есть две базы данных, то 
			они должны правильно разделять области игрового пространства не вызывая коллизий друг у друга. 
			Размещение в них данных не должно дублироваться или если есть необходимость в дублировании оно должно
			быть регулируемым. Если задуматься над базами данных дожен стоять еще однин объект регулирующий
			порядок сохранения данных в них. Или каждая из баз должна точно распозновать область данных, 
			кторую хранит в себе
			
		3. Как должна проходить обработка объекта в базах?
			
			- Сама база предоставляет только структуру, а также статически тул-сет для работы с объектами,
			специализированный для среды базы. Значит обработка должна выполнятся внешне. Обработчик дожен
			просто получать следующий необработанный объект из базы после завершения обработки предыдущего.
			- База должна иметь счетчик синхронизации, основной задачей счетка будет определение этапа
			обработки объектов в базе. Второй ролью будет синхронизация инстансов баз в случае если их будет 
			несколько, также по счетчику будет определятся производительность обработчиков подключенных
			в к конкретному серверу. Предполагается что обработчики в том числе смогут работать с других машин,
			находящихся на большом удалении от основного сервера, такой вариант даже при наличии большой задержки
			(более 10 мс) сможет обрабатывать объекты требующие редкой обработки тем самым снимая нагрузку
			с более быстрых обработчиков.
			
		4. Принципы и правила расширения объема окто-базы
		
			- Важным моментом для OkTree будет необходимость касания секторов гранями. Они должны прилегать друг 
			к другу.
			- Базу расширяет движение объекта внутри нее. То есть если у нас есть предмет летящий внутри объема
			базы то она расширяется, но это не значит что каждый следующий сектор (ячейка) через который к примеру 
			пройдет одиночный предмет должен оставаться в базе постоянно загруженным. Если в конкретной ячейке
			объема нету ничего, то такую ячейку можно просто считать пустой и не обрабатывать совсем. Нужно ли
			удалять уже существующие ячейки? Возможно, что у них должно быть время жизни, ведь каждая ячейка
			в каком то смысле игровой объект.
			- Каждая ячейка находится исключительно внутри базы и внешним объектом являтся не должна,
			единственным проявлением должна стать возможность отображать выбранный Layer ячеек при моделировании
			пространства в UI и то в режие отладки.
			- Добавление ячейки базы выполняет внешний обработчик. Если при запросе обработчика о том, существует ли 
			пространство в которое ему необзходимо перенести объект, возвращается негативный 
			ответ тогда запускается создание новояй ячейки максимального размера в соответствующей области 
			объема.
			
		5. Загрузка ячеек окто-базы
			
			- Простой способ проверки, как проверка на достижение каждого из углов ячейки радиусом сферы загрузки
			подходит только для проверки на полное вхождение ячейки в сферу.
			- Для нахождения частичного пересечения или полного пересечения нужно искать другой способ. В голове 
			крутится мысль - построить треугольник, две точки треугольника будут центрами фигур, третья будет
			в ближайшей к центру сферы вершине ячейке. После этого можно будет проверить достигает ли сфера
			ближайшей вершины ячейки или точки на поверхности грани. Последняя проверка будет через расчет
			площади, который будет занимать в общем треугольнике та часть, которая принадлежит сфере и та часть
			которая принадлежит ячейке. Математическая часть способа выглядит так:
				1. Считаем площадь самого треугольника.
				2. Ищем точку в основании треугольника в месте, где грань ячейки пересекается с прямой
				соединяющей центры фигур, а также находим ближайшую к сфере вершину ячейки.
				3. Можем рассчитать площадь которую в треугольнике занимает часть принадлежащая ячейке.
				4. Зная точку ближайшей к сфере вершины ячейки и точку пересечения грани ячейки, можно узнать угол
				сектора сферы и получить его объем. В этот же момент оба отрезка можно проверить на - 1. наложение
				радиуса сферы на ту часть отрезка которая находится внутри ячейки и 2. превышение длинны
				грани сектора сферы над длинной грани треугольника. Так без расчета площади можно сказать
				что сфера пересекается с ячейкой.
				5. Последняя часть наиболее сложная, так как требует нахождения площади на поверхности треугольника
				не занятой ни одним из объектов. Из условий которые у нас уже имеются мы можем точно знать,
				что ни один из углов основания сектора не находится внутри ячейки или не прошел за ближайшую к 
				центру сферы вершину. Также имеем уже расчитанные площади сектора среза сферы и треугольника ячейки.
				Теперь можно расчитать площадь треугольника в котрый входит сектор принадлежащий сфере. Первая его
				вершина в центре сферы, вторая на ближайшей вершине ячейки, третья в точке пересечения с гранью
				ячейки.
				
		