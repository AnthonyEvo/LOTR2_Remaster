	--- Заметки по OkTree Data Base ---
	
		1. Алгоритм создания базы это заполнение прямоугольной декартовой сетки максимально 
		большими ячейками в пределах начального размера игрового (визуального) объема. Возможно максимальный 
		размер будет всего одна ячейка если	она достаточно большая для заполнения ее внутриигровыми объектами. 
		Важно предусмотреть ограничения и исключения при рисовании объектов разного размера в пределах 
		минимальной ячейки, осбенно важен объем их детализации.	
		
		2. Отслеживание объектов для отрисовки должно идти каскадом от самой большой ящейки до самой малой.
		Алгоритм следующий - камера запрашивает большие ячейки у БД, получает ячейки с которыми пересекается
		ее область обзора.
		Для реализации этого понадбится "Bound box" причем несколько его видов. Потом у ячеек
		камера запрашивает подъячейки, это повторяется до самого малого их размера. 
		После камера получает список объектов из ячеек которые были отфильтрованы из базы. 
		После идет фильтрация тех объектов которые попали в поле зрения камеры, 
		остальные кэшируются для дальнейшего использованя в случае разворота камеры.
		
		3. База объектов для игры должна быть универсальной при использовании ее как для логики игры, так и для
		других целей. Это означает что сохранение игровых сессий не должно быть тем же процессом, что и сохранение 
		объектов графики, композиций объектов и других результатов работы графического движка.
		
		4. Нужна будет база объектов для тестирования работы движка.
		
	--- Общие заметки (или заметки которые еще не специализированны) ---
	
		1. Последовательность работы при обработке графики:
		
			1.1 Добавление данных в базу отрисовки;
				- нужен алгоритм добавления объектов в базу, пока речь только об OkTree
				Объект нужно маркировать на каждой ступени базы, а также он должен менять свою маркировку при
				пересечении границ ячеек базы, это вызовет дополнительные расходы производительности.
				
			1.2 Добавление в базу активных маркеров отрисовки (т.е. камер) также камеры нужно 
			добавить в отдельный список для ускорения доступа;
				- Список должен быть привязан к среде одного воплощения\источника (Instance), возможно
				это таже база данных просто с отдельным списком для спецобъектов
				
			1.3 Прохождение алгоритма фильтрации объектов;
				- алгоритмы фильтрации объектов для разных баз будут свои и описаны в заметках про базы данных
				
			1.4 Рисование объекта в привязанном интерфейсе.
				- потребуется преработка системы отображения и сборка сетевого клинта, который сможет отправлять
				информацию на другой ПК.
				- нужно продумать способ обновления собранного проекта до актуальной версии, 
				чтобы система могла обновить себя сама имея определенным образом маркированный пакет с новыми
				исполняемыми файлами. 
		
		2. Правильный подход к внутриигровым расчетам
		
			2.1 Нужно построить систему таким образом, что бы задачи объектов по расчету их взаимодействий
			и внутренних операций масштабировались на количество исполнителей и не зависели друг от друга.
			По сути построить это взаимодействие таким образом: 
			конетйнер с задачей -> расчет -> возврат контейнера с результатом.
			
			2.2 В такой системе нужно иметь какие-то стандартные контейнеры для расчетов и достаточно простой
			алгоритм расчета для каждого контейнера. Под простотой тут подразумевается что инструмент для 
			их обработки должен быть универсальными. Получается что в рамках одного клиентского приложения 
			есть три отдельных типа объекта, первый тип объектов сосредоточен на вмещении в себе объектов и обмене 
			информацией второй на обработке состояний и поведения объектов в соответствии с правилами, третий на
			передаче команд влияющих на поведение обектов и на их отображении для пользователя. Третий тип все же 
			не полноценный из-за того, что его наличие не обязательно для продолжения работы.
			
			2.3 Просматривается следующая система:
			- условно первый тип это базы данных и инструменты анализа их содержимого, а также системы связи с ними;
			- второй тип это обработчики событий и инструменты контроля выполняющие задачи по испольнению правил
			поведения объектов, обработке их внутренних расчетов
			- третий тип чем-то похож на второй тип, он также как и второй запрашивает определенные объекты у базы
			данных, и выполняет определенную обработку этих объектов устанавливая им маркеры управления для 
			обработчиков событий.
			
			2.4 Если продолжать логику то условно три типа объетов позволяют построить своего рода треугольник
			в котором основным элементом для взаимодействия выступает база данных. Но если пытаться расширить 
			систему то трех элементов становится мало. В случае если в такой системе есть две базы данных, то 
			они должны правильно разделять области игрового пространства не вызывая коллизий друг у друга. 
			Размещение в них данных не должно дублироваться или если есть необходимость в дублировании оно должно
			быть регулируемым. Если задуматься над базами данных дожен стоять еще однин объект регулирующий
			порядок сохранения данных в них. Или каждая из баз должна точно распозновать область данных, 
			кторую хранит в себе
			
		3. Как должна проходить обработка объекта в базах?
			
			- Сама база предоставляет только структуру, а также статически тул-сет для работы с объектами,
			специализированный для среды базы. Значит обработка должна выполнятся внешне. Обработчик дожен
			просто получать следующий необработанный объект из базы после завершения обработки предыдущего.
			- База должна иметь счетчик синхронизации, основной задачей счетка будет определение этапа
			обработки объектов в базе. Второй ролью будет синхронизация инстансов баз в случае если их будет 
			несколько, также по счетчику будет определятся производительность обработчиков подключенных
			в к конкретному серверу. Предполагается что обработчики в том числе смогут работать с других машин,
			находящихся на большом удалении от основного сервера, такой вариант даже при наличии большой задержки
			(более 10 мс) сможет обрабатывать объекты требующие редкой обработки тем самым снимая нагрузку
			с более быстрых обработчиков.
			
		4. Принципы и правила расширения объема базы 
		
			- Важным моментом для OkTree будет необходимость касания секторов гранями. Они должны прилегать друг 
			к другу.
			- Базу расширяет движение объекта внутри нее. То есть если у нас есть предмет летящий внутри объема
			базы то она расширяется, но это не значит что каждый следующий сектор (ячейка) через который к примеру 
			пройдет одиночный предмет должен оставаться в базе постоянно загруженным. Если в конкретной ячейке
			объема нету ничего, то такую ячейку можно просто считать пустой и не обрабатывать совсем. Нужно ли
			удалять уже существующие ячейки? Возможно что у них должно быть время жизни, ведь каждая ячейка
			в каком то смысле игровой объект.
			- Каждая ячейка находится исключительно внутри базы и внешним объектом являтся не должна,
			единственным проявлением должна стать возможность отображать выбранный Layer ячеек при моделировании
			пространства в UI и то в режие отладки.
			- Добавление ячейки базы выполняет внешний обработчик. Возможно при запросе входит ли пространство в
			которое ему необзходимо перенести объект после обработки получает негативный ответ и тогда
			запускается создание новояй ячейки максимального размера в соответствующе области объема.